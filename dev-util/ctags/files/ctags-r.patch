diff -Naur ctags-5.8.orig/parsers.h ctags-5.8/parsers.h
--- ctags-5.8.orig/parsers.h	2012-02-14 11:25:31.000000000 +0100
+++ ctags-5.8/parsers.h	2012-02-15 16:30:38.000000000 +0100
@@ -1,4 +1,4 @@
-/*
+RParser/*
 *   $Id: parsers.h 717 2009-07-07 03:40:50Z dhiebert $
 *
 *   Copyright (c) 2000-2003, Darren Hiebert
@@ -44,6 +44,7 @@
 	PhpParser, \
 	PythonParser, \
 	RexxParser, \
+        RParser, \
 	RubyParser, \
 	SchemeParser, \
 	ShParser, \
diff -Naur ctags-5.8.orig/r.c ctags-5.8/r.c
--- ctags-5.8.orig/r.c	1970-01-01 01:00:00.000000000 +0100
+++ ctags-5.8/r.c	2012-02-15 16:27:46.000000000 +0100
@@ -0,0 +1,225 @@
+/***************************************************************************
+ * css.c
+ * Character-based parser for Css definitions
+ * Author - Iago Rubio <iagorubio(at)users.sourceforge.net>
+ **************************************************************************/
+#include "general.h"
+
+#include <string.h>
+#include <ctype.h>
+
+#include "parse.h"
+#include "read.h"
+
+
+typedef enum eRKinds {
+    K_NONE = -1, K_CLASS, K_SELECTOR, K_ID
+} RKind;
+
+static kindOption RKinds [] = {
+    { TRUE, 'c', "class", "classes" },
+    { TRUE, 's', "selector",  "selectors"  },
+    { TRUE, 'i', "id",  "identities"  }
+};
+
+typedef enum _RParserState {  // state of parsing
+  P_STATE_NONE,         // default state
+  P_STATE_IN_COMMENT,     // into a comment, only multi line in CSS
+  P_STATE_IN_SINGLE_STRING, // into a single quoted string
+  P_STATE_IN_DOUBLE_STRING, // into a double quoted string
+  P_STATE_IN_DEFINITION,    // on the body of the style definition, nothing for us
+  P_STATE_IN_MEDIA,     // on a @media declaration, can be multi-line
+  P_STATE_IN_IMPORT,      // on a @import declaration, can be multi-line
+  P_STATE_IN_NAMESPACE,   // on a @namespace declaration
+  P_STATE_IN_PAGE,      // on a @page declaration
+  P_STATE_IN_FONTFACE,    // on a @font-face declaration
+  P_STATE_AT_END        // end of parsing
+} RParserState;
+
+static void makeRSimpleTag( vString *name, RKind kind, boolean delete )
+{
+  vStringTerminate (name);
+  makeSimpleTag (name, RKinds, kind);
+  vStringClear (name);
+  if( delete )
+    vStringDelete (name);
+}
+
+static boolean isRDeclarationAllowedChar( const unsigned char *cp )
+{
+  return  isalnum ((int) *cp) ||
+      isspace ((int) *cp) ||
+      *cp == '_' || // allowed char
+      *cp == '-' || // allowed char
+      *cp == '+' ||   // allow all sibling in a single tag
+      *cp == '>' ||   // allow all child in a single tag
+      *cp == '{' ||   // allow the start of the declaration
+      *cp == '.' ||   // allow classes and selectors
+      *cp == ',' ||   // allow multiple declarations
+      *cp == ':' ||   // allow pseudo classes
+      *cp == '*' ||   // allow globs as P + *
+      *cp == '#';   // allow ids
+}
+
+static RParserState parseRDeclaration( const unsigned char **position, RKind kind )
+{
+  vString *name = vStringNew ();
+  const unsigned char *cp = *position;
+
+  // pick to the end of line including children and sibling
+  // if declaration is multiline go for the next line
+  while ( isRDeclarationAllowedChar(cp) ||
+      *cp == '\0' )   // track the end of line into the loop
+  {
+    if( (int) *cp == '\0' )
+    {
+      cp = fileReadLine ();
+      if( cp == NULL ){
+        makeRSimpleTag(name, kind, TRUE);
+        *position = cp;
+        return P_STATE_AT_END;
+      }
+    }
+    else if( *cp == ',' )
+    {
+      makeRSimpleTag(name, kind, TRUE);
+      *position = ++cp;
+      return P_STATE_NONE;
+    }
+    else if( *cp == '{' )
+    {
+      makeRSimpleTag(name, kind, TRUE);
+      *position = ++cp;
+      return P_STATE_IN_DEFINITION;
+    }
+
+    vStringPut (name, (int) *cp);
+    ++cp;
+  }
+
+  makeRSimpleTag(name, kind, TRUE);
+  *position = cp;
+
+  return P_STATE_NONE;
+}
+
+static RParserState parseRLine( const unsigned char *line, RParserState state )
+{
+  vString *aux;
+
+  while( *line != '\0' ) // fileReadLine returns NULL terminated strings
+  {
+    while (isspace ((int) *line))
+      ++line;
+    switch( state )
+    {
+      case P_STATE_NONE:
+        // pick first char if alphanumeric is a selector
+        if( isalnum ((int) *line) )
+          state = parseRDeclaration( &line, K_SELECTOR );
+        else if( *line == '.' ) // a class
+          state = parseRDeclaration( &line, K_CLASS );
+        else if( *line == '#' ) // an id
+          state = parseRDeclaration( &line, K_ID );
+        else if( *line == '@' ) // at-rules, we'll ignore them
+        {
+          ++line;
+          aux = vStringNew();
+          while( !isspace((int) *line) )
+          {
+            vStringPut (aux, (int) *line);
+            ++line;
+          }
+          vStringTerminate (aux);
+          if( strcmp( aux->buffer, "media" ) == 0 )
+            state = P_STATE_IN_MEDIA;
+          else if ( strcmp( aux->buffer, "import" ) == 0 )
+            state = P_STATE_IN_IMPORT;
+          else if ( strcmp( aux->buffer, "namespace" ) == 0 )
+            state = P_STATE_IN_NAMESPACE;
+          else if ( strcmp( aux->buffer, "page" ) == 0 )
+            state = P_STATE_IN_PAGE;
+          else if ( strcmp( aux->buffer, "font-face" ) == 0 )
+            state = P_STATE_IN_FONTFACE;
+          vStringDelete (aux);
+        }
+        else if( *line == '*' && *(line-1) == '/' ) // multi-line comment
+          state = P_STATE_IN_COMMENT;
+      break;
+      case P_STATE_IN_COMMENT:
+        if( *line == '/' && *(line-1) == '*')
+          state = P_STATE_NONE;
+      break;
+      case  P_STATE_IN_SINGLE_STRING:
+        if( *line == '\'' && *(line-1) != '\\' )
+          state = P_STATE_IN_DEFINITION; // PAGE, FONTFACE and DEFINITION are treated the same way
+      break;
+      case  P_STATE_IN_DOUBLE_STRING:
+        if( *line=='"' && *(line-1) != '\\' )
+          state = P_STATE_IN_DEFINITION; // PAGE, FONTFACE and DEFINITION are treated the same way
+      break;
+      case  P_STATE_IN_MEDIA:
+        // skip to start of media body or line end
+        while( *line != '{' )
+        {
+          if( *line == '\0' )
+            break;
+          ++line;
+        }
+        if( *line == '{' )
+            state = P_STATE_NONE;
+      break;
+      case  P_STATE_IN_IMPORT:
+      case  P_STATE_IN_NAMESPACE:
+        // skip to end of declaration or line end
+        while( *line != ';' )
+        {
+          if( *line == '\0' )
+            break;
+          ++line;
+        }
+        if( *line == ';' )
+          state = P_STATE_NONE;
+      break;
+      case P_STATE_IN_PAGE:
+      case P_STATE_IN_FONTFACE:
+      case P_STATE_IN_DEFINITION:
+        if( *line == '}' )
+          state = P_STATE_NONE;
+        else if( *line == '\'' )
+          state = P_STATE_IN_SINGLE_STRING;
+        else if( *line == '"' )
+          state = P_STATE_IN_DOUBLE_STRING;
+      break;
+      case P_STATE_AT_END:
+        return state;
+      break;
+    }
+    line++;
+  }
+  return state;
+}
+
+static void findRTags (void)
+{
+    const unsigned char *line;
+  RParserState state = P_STATE_NONE;
+
+    while ( (line = fileReadLine ()) != NULL )
+    {
+    state = parseRLine( line, state );
+    if( state==P_STATE_AT_END ) return;
+    }
+}
+
+/* parser definition */
+extern parserDefinition* RParser (void)
+{
+    static const char *const extensions [] = { "R", NULL };
+    parserDefinition* def = parserNew ("R");
+    def->kinds      = RKinds;
+    def->kindCount  = KIND_COUNT (RKinds);
+    def->extensions = extensions;
+    def->parser     = findRTags;
+    return def;
+}
diff -Naur ctags-5.8.orig/source.mak ctags-5.8/source.mak
--- ctags-5.8.orig/source.mak	2012-02-14 11:25:31.000000000 +0100
+++ ctags-5.8/source.mak	2012-02-15 16:41:51.000000000 +0100
@@ -40,6 +40,7 @@
 	perl.c \
 	php.c \
 	python.c \
+        r.c \
 	read.c \
 	rexx.c \
 	routines.c \
@@ -102,6 +103,7 @@
 	perl.$(OBJEXT) \
 	php.$(OBJEXT) \
 	python.$(OBJEXT) \
+        r.$(OBJEXT) \
 	read.$(OBJEXT) \
 	rexx.$(OBJEXT) \
 	routines.$(OBJEXT) \
